# -*- coding: utf-8 -*-
"""KMeans

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EkB9LY7YAdU_Z1bVjStYcE--o3khkVdp

# New Section
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import silhouette_score
import os

def load_dataset(dataset):
  # Check for the existence of the dataset file and raise an error if not found
    if not os.path.isfile(dataset):
        raise FileNotFoundError(f"The file {dataset} does not exist.")
    data = []
     # Open and read data from the dataset file
    with open(dataset, 'r') as file:
        for line in file:
            # Convert elements from the second element onward to floats
            numeric_values = [float(part) for part in line.strip().split()[1:]]
             # Ensure that each line contains at least two numeric values
            if len(numeric_values) < 2:
                raise ValueError("The dataset must have at least 2 numeric values per line.")
            data.append(numeric_values)

   # Convert list to a numpy array
    data_array = np.array(data)
     # Validate that the dataset contains more than one data point
    if data_array.shape[0] < 2:
        raise ValueError("The dataset must contain more than one data point.")
    return data_array


# Function to compute the Euclidean distance between two points
def ComputeDistance(point1, point2):
    return np.sqrt(np.sum((point1 - point2) ** 2))

# Function to randomly select initial centroids without replacement
def initialSelection(points, k):
    np.random.seed(42) # Seed for reproducibility
    indices = np.random.choice(points.shape[0], size=k, replace=False)
    return points[indices]

# Function to assign each data point to the nearest centroid
def assignClusterIds(points, centroids):
   # Compute all pairwise distances between points and centroids
    distances = np.sqrt(((points - centroids[:, np.newaxis]) ** 2).sum(axis=2))
    # Assign each point to the nearest centroid
    return np.argmin(distances, axis=0)


# Function to compute new centroids based on the mean of points in each cluster
def computeClusterRepresentatives(points, labels, k):
    return np.array([points[labels == i].mean(axis=0) for i in range(k)])

# Main clustering function
def clustername(x, k, maxIter=100):
    centroids = initialSelection(x, k) # Select initial centroids
    for _ in range(maxIter):
        labels = assignClusterIds(x, centroids)  # Assign cluster IDs
        new_centroids = computeClusterRepresentatives(x, labels, k)  # Compute new centroids

         # Break if centroids do not change
        if np.allclose(centroids, new_centroids):
            break
        centroids = new_centroids
    return labels, centroids

# Function to compute silhouette scores for different values of k
def compute_silhouette_scores(points, max_k):
    silhouette_scores = []
    for k in range(1, max_k + 1):
        if k == 1: # Cannot compute silhouette score for k=1
            silhouette_scores.append(None)
            continue
        # Adjust the function call here
        labels, _ = clustername(points, k, maxIter=100)
        score = silhouette_score(points, labels)
        silhouette_scores.append(score)
    return silhouette_scores

# Function to plot and save the silhouette scores for different values of k
def plot_silhouette(silhouette_scores):
    plt.figure(figsize=(10, 6))
    plt.plot(range(1, len(silhouette_scores) + 1), silhouette_scores, marker='o')
    plt.title('Silhouette Scores for Different Values of k')
    plt.xlabel('k')
    plt.ylabel('Silhouette Score')
    plt.grid(True)
    plt.savefig('silhouette_scores.png')
    plt.show()


# Main execution block to load dataset, compute scores, and plot results
if __name__ == "__main__":
    try:
        points = load_dataset("dataset")
        silhouette_scores = compute_silhouette_scores(points, 9)
        plot_silhouette(silhouette_scores)
    except Exception as e:
        print(f"An error occurred: {e}")