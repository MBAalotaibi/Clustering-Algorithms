# -*- coding: utf-8 -*-
"""KMeansSynthetic

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Vu8Azd4V3eYvJKCCtnfrzFTOoijwP3hh
"""

import numpy as np
import matplotlib.pyplot as plt
import os

# Function to load a dataset from a file
def load_dataset(dataset):
  # Check if the file exists; raise an error if it does not
    if not os.path.isfile(dataset):
        raise FileNotFoundError(f"The file {dataset} does not exist.")
    data = []
    # Read the file and extract data
    with open(dataset, 'r') as file:
        for line in file:
           # Convert each line's numeric values to floats, skipping the first element
            numeric_values = [float(part) for part in line.strip().split()[1:]]
             # Validate that there are at least two numeric values per line
            if len(numeric_values) < 2:
                raise ValueError("The dataset must have at least 2 numeric values per line.")
            data.append(numeric_values)
    return np.array(data)

# Function to generate synthetic data based on the original dataset
def generate_synthetic_data(original_data, seed=42):
    np.random.seed(seed) # Seed for reproducibility
    optimal_scale_factor = 0.5
    num_points, num_features = original_data.shape
    data_mean = np.mean(original_data, axis=0)
    data_covariance = np.cov(original_data.T) * optimal_scale_factor
    synthetic_data = np.random.multivariate_normal(data_mean, data_covariance, num_points)
    return synthetic_data


# Function to calculate the Euclidean distance between two points
def ComputeDistance(point1, point2):
    return np.sqrt(np.sum((point1 - point2) ** 2))

# Function to select initial centroids randomly without replacement
def initialSelection(points, k):
    np.random.seed(42)
    indices = np.random.choice(points.shape[0], size=k, replace=False)
    return points[indices]


# Function to compute new centroids based on the current cluster assignments
def assignClusterIds(points, centroids):
    distances = np.sqrt(((points - centroids[:, np.newaxis]) ** 2).sum(axis=2))
    return np.argmin(distances, axis=0)

# Clustering algorithm function to determine cluster labels and centroids
def computeClusterRepresentatives(points, labels, k):
    return np.array([points[labels == i].mean(axis=0) for i in range(k)])

def clustername(points, k, max_iter=100):
    centroids = initialSelection(points, k)
    for _ in range(max_iter):
        labels = assignClusterIds(points, centroids)
        new_centroids = computeClusterRepresentatives(points, labels, k)
        if np.allclose(centroids, new_centroids):
            break
        centroids = new_centroids
    return labels, centroids


# Function to compute silhouette scores for a range of k values
def silhouette_score_manual(points, labels):
    n = points.shape[0]
    silhouette_scores = np.zeros(n)

    # Compute the distance matrix
    distance_matrix = np.array([[ComputeDistance(p1, p2) for p2 in points] for p1 in points])

    # Calculate silhouette scores for each point
    for i in range(n):
        own_cluster = labels[i]
        in_cluster_distances = distance_matrix[i, labels == own_cluster]
        mean_intra_cluster_distance = np.mean(in_cluster_distances)

        mean_nearest_cluster_distance = np.inf
        for cluster in set(labels):
            if cluster == own_cluster:
                continue
            inter_cluster_distances = distance_matrix[i, labels == cluster]
            mean_distance = np.mean(inter_cluster_distances)
            mean_nearest_cluster_distance = min(mean_nearest_cluster_distance, mean_distance)

        silhouette_scores[i] = (mean_nearest_cluster_distance - mean_intra_cluster_distance) / max(mean_intra_cluster_distance, mean_nearest_cluster_distance)

    return np.mean(silhouette_scores)

# Function to compute silhouette scores for a range of k values
def compute_silhouette_scores(points, max_k):
    silhouette_scores = []
    for k in range(2, max_k + 1):  # silhouette score isn't defined for k=1
        labels, _ = clustername(points, k, max_iter=100)
        score = silhouette_score_manual(points, labels)
        silhouette_scores.append(score)
    return silhouette_scores

# Function to plot the computed silhouette scores
def plot_silhouette(silhouette_scores):
    plt.figure(figsize=(10, 6))
    k_range = range(2, len(silhouette_scores) + 2)
    plt.plot(k_range, silhouette_scores, 'bx-')
    plt.title('Silhouette Scores for Different Values of k (Synthetic Data)')
    plt.xlabel('k')
    plt.ylabel('Silhouette Score')
    plt.xticks(k_range)
    plt.grid(True)
    plt.show()


if __name__ == "__main__":
    try:
        original_data = load_dataset("dataset")
        # Generate synthetic data using a more refined scale factor
        synthetic_data = generate_synthetic_data(original_data)
        silhouette_scores_synthetic = compute_silhouette_scores(synthetic_data, 9)
        plot_silhouette(silhouette_scores_synthetic)
    except Exception as e:
        print(f"An error occurred: {e}")